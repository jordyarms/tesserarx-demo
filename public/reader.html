<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot Reader — Tesserarx</title>
    <meta name="description" content="TDP-1.0 compliant tarot reader. Decrypt and view your tarot deck passes.">
    
    <!-- Shared Styles -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        void: '#08090e',
                        surface: '#0f1117',
                        border: '#181b24',
                        accent: '#00c9ff',
                        accent2: '#8b7aff',
                        muted: '#9ca3af'
                    }
                }
            }
        }
    </script>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="dist/tesserarx-polkadot.umd.cjs"></script>
    <script src="content-loader.js"></script>
</head>
<body class="min-h-screen text-gray-200">
    <div class="max-w-7xl mx-auto px-6 md:px-12 py-16 md:py-24" style="padding-top: 3rem; padding-bottom: 3rem;">


        


        <!-- Header -->
        <header class="mb-24 fade-in" style="animation-delay: 0s">
            <h1 class="heading text-5xl mb-4">Tarot Reader</h1>
        </header>

        <!-- Step 1: Connect Wallet -->
        <div class="glass-card p-8 mb-6 text-center animate-fade-in-up delay-1">
            <p class="label mb-4">Step 1</p>
            <h2 class="heading text-2xl mb-6">Connect Wallet</h2>
            <button
                id="connectButton"
                onclick="connectWallet()"
                class="btn"
            >
                Connect to Moonbase Alpha
            </button>
            <div id="walletInfo" class="mt-6"></div>
        </div>

        <!-- Step 2: Select Deck -->
        <div id="deckSelector" class="glass-card p-8 mb-6 text-center hidden animate-fade-in-up delay-2">
            <p class="label mb-4">Step 2</p>
            <h2 class="heading text-2xl mb-6">Select Deck</h2>
            <select id="deckSelect" onchange="loadSelectedDeck()" class="elegant-select w-full max-w-md mx-auto mb-6 text-center cursor-pointer">
                <option value="">— Loading your decks... —</option>
            </select>
            <div id="deckInfo" class="text-sm"></div>
            <div id="loadingStatus" class="mt-6"></div>
        </div>

        <!-- Controls -->
        <div id="controls" class="text-center mb-6 hidden animate-fade-in-up delay-3" style="display: flex; gap: 0.75rem; justify-content: center; flex-wrap: wrap;">
            <button onclick="drawRandomCard()" class="btn">
                Draw Card
            </button>
            <button onclick="resetDeck()" class="btn">
                Reset Deck
            </button>
            <button onclick="showFullDeck()" class="btn">
                View Full Deck
            </button>
        </div>

        <!-- Card Display -->
        <div id="cardDisplay" class="glass-card p-8 text-center hidden">
            <div class="card-frame max-w-sm mx-auto mb-8">
                <img id="cardImage" class="w-full h-auto block" src="" alt="">
            </div>
            <div id="cardName" class="heading text-3xl mb-3"></div>
            <div id="cardKeywords" class="subheading text-sm"></div>
        </div>

        <!-- Full Deck -->
        <div id="fullDeck" class="glass-card p-8 hidden">
            <h2 class="heading text-2xl text-center mb-8">Complete Archive</h2>
            <div id="deckGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4"></div>
        </div>

    </div>

    <script>
        let currentDeck = null;
        let drawnCards = [];
        let ownedDecks = [];

        let provider, signer, contract, userAddress;

        const CONTRACT_ABI = [
            "function balanceOf(address account, uint256 id) view returns (uint256)",
            "function getActiveVersion(uint256 contentId) view returns (tuple(string payloadURI, string specificationURI, string manifestURI, uint256 timestamp, string reason, address updatedBy))",
            "function getContentInfo(uint256 contentId) view returns (address creator, string name, bool isFree, uint256 price, uint256 referralBasisPoints, uint256 maxSupply, uint256 currentSupply)"
        ];

        async function connectWallet() {
            try {
                // Use Polkadot wallet manager
                const connected = await walletManager.connect();

                if (!connected) {
                    return;
                }

                // Get provider and contract from wallet manager
                provider = await walletManager.getWeb3Provider();
                contract = await walletManager.getContract(CONTRACT_ABI);
                userAddress = walletManager.getEvmAddress();

                document.getElementById('connectButton').style.display = 'none';

                const accountName = walletManager.getAccount()?.meta?.name || 'Account';
                document.getElementById('walletInfo').innerHTML = `
                    <div class="badge badge-success inline-flex">
                        <div class="status-dot"></div>
                        <span>Connected: ${accountName} (${userAddress.slice(0, 6)}...${userAddress.slice(-4)})</span>
                    </div>
                `;
                document.getElementById('deckSelector').classList.remove('hidden');

                // Load owned decks
                await loadOwnedDecks();

            } catch (error) {
                console.error('Connection error:', error);
                alert('Connection failed: ' + error.message);
            }
        }

        async function loadOwnedDecks() {
            const selector = document.getElementById('deckSelect');
            selector.innerHTML = '<option value="">— Loading your decks... —</option>';

            try {
                // Use ContentLoader to get owned decks
                ownedDecks = await ContentLoader.loadOwnedDecks(contract, userAddress);

                if (ownedDecks.length === 0) {
                    selector.innerHTML = '<option value="">— No decks owned. Visit Market to claim. —</option>';
                    return;
                }

                // Populate dropdown with owned decks
                selector.innerHTML = '<option value="">— Choose Deck —</option>';
                ownedDecks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.contentId;
                    option.textContent = `${deck.name.toUpperCase()} [${deck.year || deck.creator}] · ID:${deck.contentId}`;
                    selector.appendChild(option);
                });

            } catch (error) {
                console.error('Failed to load owned decks:', error);
                selector.innerHTML = '<option value="">— Error loading decks —</option>';
            }
        }

        async function loadSelectedDeck() {
            const selector = document.getElementById('deckSelect');
            const contentId = parseInt(selector.value);

            if (!contentId) return;

            // Find the deck data
            const deckData = ownedDecks.find(d => d.contentId === contentId);
            if (!deckData) {
                console.error('Deck data not found for content ID:', contentId);
                return;
            }

            const statusDiv = document.getElementById('loadingStatus');
            statusDiv.innerHTML = `
                <div class="badge badge-success inline-flex mb-3">
                    <div class="status-dot"></div>
                    <span>Access Granted · ${deckData.balance} Pass${deckData.balance > 1 ? 'es' : ''}</span>
                </div>
                <div class="badge badge-warning inline-flex">
                    <div class="status-dot"></div>
                    <span>Loading Package</span>
                </div>
            `;

            try {
                // Get the active version to fetch payload URI
                const version = await contract.getActiveVersion(contentId);
                const payloadURI = ContentLoader.resolveURI(version.payloadURI);

                // Step 2: Fetch ZIP file from on-chain URI
                const response = await fetch(payloadURI);
                if (!response.ok) {
                    throw new Error(`Failed to fetch deck: ${response.status} ${response.statusText}`);
                }
                const blob = await response.blob();

                statusDiv.innerHTML = '<div class="badge badge-warning inline-flex"><div class="status-dot"></div><span>Extracting Data</span></div>';

                // Extract ZIP
                const zip = await JSZip.loadAsync(blob);

                statusDiv.innerHTML = '<div class="badge badge-warning inline-flex"><div class="status-dot"></div><span>Parsing Manifest</span></div>';

                // Load manifest - try root first, then subdirectory
                let manifestText;
                let pathPrefix = '';
                const manifestFile = zip.file('manifest.json');
                if (manifestFile) {
                    manifestText = await manifestFile.async('string');
                } else {
                    // Look for manifest in subdirectory
                    const files = Object.keys(zip.files);
                    const manifestPath = files.find(f => f.endsWith('manifest.json') && !f.includes('__MACOSX'));
                    if (!manifestPath) {
                        throw new Error('manifest.json not found in package');
                    }
                    manifestText = await zip.file(manifestPath).async('string');
                    // Extract the path prefix (e.g., "anecdotes-tarot/")
                    pathPrefix = manifestPath.replace('manifest.json', '');
                }
                const manifest = JSON.parse(manifestText);

                statusDiv.innerHTML = '<div class="badge badge-warning inline-flex"><div class="status-dot"></div><span>Loading Images</span></div>';

                // Load all card images
                const cards = [];
                for (const file of manifest.files.image_list) {
                    const imageData = await zip.file(pathPrefix + file.path).async('base64');
                    const ext = file.filename.split('.').pop().toLowerCase();
                    const mimeType = ext === 'svg' ? 'image/svg+xml' : `image/${ext}`;

                    // Find card info from manifest
                    let cardInfo = null;
                    for (const card of manifest.card_map.major_arcana) {
                        if (file.filename.includes(card.id)) {
                            cardInfo = { ...card, type: 'major', filename: file.filename, data: imageData, mimeType };
                            break;
                        }
                    }

                    if (!cardInfo) {
                        for (const [suitName, suit] of Object.entries(manifest.card_map.suits)) {
                            for (const card of suit.cards) {
                                if (file.filename.includes(card.id)) {
                                    cardInfo = { ...card, type: 'minor', suit: suitName, filename: file.filename, data: imageData, mimeType };
                                    break;
                                }
                            }
                            if (cardInfo) break;
                        }
                    }

                    if (cardInfo) {
                        cards.push(cardInfo);
                    }
                }

                currentDeck = {
                    manifest,
                    cards
                };

                drawnCards = [];

                // Update UI
                document.getElementById('deckInfo').innerHTML = `
                    <div class="heading text-lg mb-3">${manifest.deck_name}</div>
                    <div class="subheading text-xs space-y-1">
                        <div>${manifest.structure.total_cards} cards loaded</div>
                        <div>Protocol: TDP-${manifest.version}</div>
                        <div>Format: ${manifest.structure.format}</div>
                    </div>
                `;

                statusDiv.innerHTML = `
                    <div class="badge badge-success inline-flex">
                        <div class="status-dot"></div>
                        <span>Loaded ${cards.length} Cards</span>
                    </div>
                `;

                document.getElementById('controls').classList.remove('hidden');

            } catch (error) {
                console.error('Load error:', error);
                statusDiv.innerHTML = `
                    <div class="badge badge-error inline-flex mb-3">
                        <span>System Error</span>
                    </div>
                    <p class="text-sm subheading">${error.message}</p>
                `;
            }
        }

        function drawRandomCard() {
            if (!currentDeck) return;

            const availableCards = currentDeck.cards.filter(card =>
                !drawnCards.includes(card.id)
            );

            if (availableCards.length === 0) {
                alert('All cards have been drawn. Reset the deck to continue.');
                return;
            }

            const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
            drawnCards.push(randomCard.id);
            displayCard(randomCard);
        }

        function displayCard(card) {
            const cardDisplay = document.getElementById('cardDisplay');
            const cardImage = document.getElementById('cardImage');
            const cardName = document.getElementById('cardName');
            const cardKeywords = document.getElementById('cardKeywords');

            cardImage.src = `data:${card.mimeType};base64,${card.data}`;
            cardName.textContent = card.name;
            cardKeywords.textContent = card.keywords ? card.keywords.join(' · ') : '';

            cardDisplay.classList.remove('hidden');
            document.getElementById('fullDeck').classList.add('hidden');
        }

        function resetDeck() {
            drawnCards = [];
            document.getElementById('cardDisplay').classList.add('hidden');
            alert('Deck reset. All cards are available again.');
        }

        function showFullDeck() {
            if (!currentDeck) return;

            const deckGrid = document.getElementById('deckGrid');
            deckGrid.innerHTML = '';

            currentDeck.cards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'grid-item cursor-pointer rounded-lg overflow-hidden';
                cardDiv.onclick = () => displayCard(card);

                const img = document.createElement('img');
                img.src = `data:${card.mimeType};base64,${card.data}`;
                img.alt = card.name;
                img.title = card.name;
                img.className = 'w-full rounded-lg';

                cardDiv.appendChild(img);
                deckGrid.appendChild(cardDiv);
            });

            document.getElementById('cardDisplay').classList.add('hidden');
            document.getElementById('fullDeck').classList.remove('hidden');
        }
    </script>

    <script src="nav-component.js"></script>
</body>
</html>
